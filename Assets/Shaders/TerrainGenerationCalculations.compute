#pragma kernel ErodeDroplets
#pragma kernel GetHeights
#pragma kernel ApplyDeltas
#pragma kernel CalculateBrightness
#pragma kernel Saturate

RWTexture2D<float> Height, Delta, Saturated;
RWTexture2D<int> HeightDelta, MinBrightness, MaxBrightness;

int width;
int height;
int numDrops;
uint seed;

int numStepsPerDrop;
int erodeRadius;
float depositRadius;
float initialWater;
float initialSpeed;
float inertia;
float erosionFactor;
float depositionFactor;
float evaporation;
float capacityFactor;
float minCapacity;
float stepScale;
float randJitter;

static const float SCALE = 1000000.0;

int FloatToInt(float v)
{
    float clamped = clamp(v, -2e6, 2e6);
    return (int)round(clamped * SCALE);
}
float IntToFloat(int v) { return (v / SCALE); }

float Rand01(inout uint state)
{
    state = state * 1664525u + 1013904223u;
    return (state & 0x00FFFFFF) / 16777216.0;
}

int2 ClampInt2(int2 p)
{
    p.x = clamp(p.x, 0, width - 1);
    p.y = clamp(p.y, 0, height - 1);
    return p;
}

float ReadPixelIntAware(int2 p)
{
    int2 c = ClampInt2(p);
    return Height[c] + IntToFloat(HeightDelta[c]);
}

float ReadHeightBilinear(float2 pos)
{
    int2 i00 = ClampInt2(int2(floor(pos.x), floor(pos.y)));
    int2 i10 = ClampInt2(i00 + int2(1, 0));
    int2 i01 = ClampInt2(i00 + int2(0, 1));
    int2 i11 = ClampInt2(i00 + int2(1, 1));

    float2 f = frac(pos);

    float h00 = ReadPixelIntAware(i00);
    float h10 = ReadPixelIntAware(i10);
    float h01 = ReadPixelIntAware(i01);
    float h11 = ReadPixelIntAware(i11);

    float hx0 = lerp(h00, h10, f.x);
    float hx1 = lerp(h01, h11, f.x);
    return lerp(hx0, hx1, f.y);
}

float2 ComputeGradient(float2 pos)
{
    float hl = ReadHeightBilinear(pos + float2(-1, 0));
    float hr = ReadHeightBilinear(pos + float2( 1, 0));
    float hd = ReadHeightBilinear(pos + float2(0, -1));
    float hu = ReadHeightBilinear(pos + float2(0,  1));
    return float2((hr - hl) * 0.5, (hu - hd) * 0.5);
}

void AtomicAddHeight(float2 pos, float amount)
{
    int2 center = ClampInt2(int2(floor(pos.x), floor(pos.y)));
    float2 rest = float2(frac(pos.x), frac(pos.y));

    int v00 = FloatToInt(amount * (1 - rest.x) * (1 - rest.y));
    int v10 = FloatToInt(amount * rest.x * (1 - rest.y));
    int v01 = FloatToInt(amount * (1 - rest.x) * rest.y);
    int v11 = FloatToInt(amount * rest.x * rest.y);

    // Always clamp targets â€” don't skip contributions
    InterlockedAdd(HeightDelta[ ClampInt2(center + int2(0,0)) ], v00);
    InterlockedAdd(HeightDelta[ ClampInt2(center + int2(1,0)) ], v10);
    InterlockedAdd(HeightDelta[ ClampInt2(center + int2(0,1)) ], v01);
    InterlockedAdd(HeightDelta[ ClampInt2(center + int2(1,1)) ], v11);
}


float ErodeDistributed(float2 pos, float desired)
{
    int r = max(1, erodeRadius);
    float totalWeight = 0.0;

    for (int ky = -r; ky <= r; ++ky)
    {
        for (int kx = -r; kx <= r; ++kx)
        {
            float dist = sqrt((float)(kx*kx + ky*ky));
            if (dist <= r) totalWeight += (1.0 - (dist / (r + 0.0001)));
        }
    }

    if (totalWeight <= 0.0) return 0.0;

    float removedSum = 0.0;

    int2 center = int2(floor(pos.x), floor(pos.y));

    for (int ky = -r; ky <= r; ++ky)
    {
        for (int kx = -r; kx <= r; ++kx)
        {
            float dist = sqrt((float)(kx*kx + ky*ky));
            if (dist <= r)
            {
                int2 sample = center + int2(kx, ky);
                if (sample.x < 0 || sample.x >= width-1 || sample.y < 0 || sample.y >= height-1) continue;

                float w = (1.0 - (dist / (r + 0.0001)));
                float localPos = desired * (w / totalWeight);

                int toRemoveInt = FloatToInt(localPos);

                if (toRemoveInt == 0)
                {
                    continue;
                }

                InterlockedAdd(HeightDelta[sample], -toRemoveInt);

                removedSum += IntToFloat(toRemoveInt);
            }
        }
    }

    return removedSum;
}

[numthreads(64,1,1)]
void ErodeDroplets(uint3 id:SV_DispatchThreadID)
{
    uint tid = id.x;
    if ((int)tid >= numDrops) return;

    uint state = seed + tid * 747796405u;
    float2 pos = float2(Rand01(state)*(width-1), Rand01(state)*(height-1));
    pos += (Rand01(state)-0.5)*randJitter;

    float water = initialWater;
    float sediment = 0.0;
    float speed = initialSpeed;
    float2 velocity = float2(0,0);

    for (int s = 0; s < numStepsPerDrop; s++)
    {
        pos = clamp(pos, float2(0,0), float2(width-1, height-1));

        float heightNow = ReadHeightBilinear(pos);
        float2 grad = ComputeGradient(pos);
        float2 dir = -normalize(grad + 1e-8);

        velocity = velocity * inertia + dir * (1.0 - inertia);

        float newSpeed = speed + (heightNow - ReadHeightBilinear(pos + velocity * stepScale)) * 0.5;
        speed = max(0.0, newSpeed);

        pos += velocity * speed * stepScale;
        pos = clamp(pos, float2(0,0), float2(width-1, height-1));

        float newH = ReadHeightBilinear(pos);
        float slope = heightNow - newH;

        float capacity = max(minCapacity, speed * water * abs(slope) * capacityFactor);

        float diff = capacity - sediment;

        if (diff < 0.0)
        {
            float depositAmount = -diff * depositionFactor;

            depositAmount = min(depositAmount, sediment);

            if (depositAmount > 0.0)
            {
                AtomicAddHeight(pos, depositAmount);
                sediment -= depositAmount;
            }
        }
        else
        {
            float desiredErode = diff * erosionFactor;

            desiredErode = min(desiredErode, max(0.0, heightNow) * 0.99);

            if (desiredErode > 0.0)
            {
                float actualRemoved = ErodeDistributed(pos, desiredErode);

                if (actualRemoved > 0.0)
                {
                    sediment += actualRemoved;
                }
            }
        }

        water *= (1.0 - evaporation);
        if (water <= 1e-6 || speed <= 1e-6) break;
    }

    if (sediment > 0.0)
    {
        AtomicAddHeight(pos, sediment);
    }
}

[numthreads(8,8,1)]
void GetHeights(uint3 id : SV_DispatchThreadID)
{
    if (id.x >= width || id.y >= height) return;
    int2 p = int2(id.x, id.y);
    int deltaInt = HeightDelta[p];
    if (deltaInt != 0)
    {
        float delta = IntToFloat(deltaInt);
        Delta[p] += delta;
        HeightDelta[p] = 0;
    }
}

[numthreads(8,8,1)]
void ApplyDeltas(uint3 id : SV_DispatchThreadID)
{
    if (id.x >= width || id.y >= height) return;
    int2 p = int2(id.x, id.y);
    Height[p] += Delta[p];
}

[numthreads(8,8,1)]
void CalculateBrightness(uint3 id : SV_DispatchThreadID)
{
    if (id.x >= width || id.y >= height) return;
    int2 p = int2(id.x, id.y);
    float brightness = Delta[p];
    p = int2(0,0);
    InterlockedMax(MaxBrightness[p], FloatToInt(brightness));
    InterlockedMin(MinBrightness[p], FloatToInt(brightness));
}

[numthreads(8,8,1)]
void Saturate(uint3 id : SV_DispatchThreadID)
{
    if (id.x >= width || id.y >= height) return;
    int2 p = int2(id.x, id.y);
    int2 o = int2(0,0);
    float brightness = Delta[p];
    float min = IntToFloat(MinBrightness[o]);
    float max = IntToFloat(MaxBrightness[o]);
    float norm = brightness / (max - min) - min;
    Saturated[p] = norm;
}
